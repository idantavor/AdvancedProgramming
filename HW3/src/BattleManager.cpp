#include "BattleManager.h"
#include "IBattleshipGameAlgo.h"
#include "UserFleet.h"
#include <fstream>
#include <windows.h>
#include <iostream>
#include <winapifamily.h>
#include <functional>
#include <memory>
#include <vector>
#include "dirent.h"
#include "Ship.h"
#include <string>
#include "InflatableBoat.h"
#include "battleship.h"
#include "submarine.h"
#include "missileBoat.h"
#include "Utility.h"




IBattleshipGameAlgo* BattleManager::loadFromDLL(string path)
{	
	UINT oldMode = SetErrorMode(0);
	SetErrorMode(oldMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
		IBattleshipGameAlgo * instance;
		HINSTANCE hDll;
		try {
		// Load dynamic library 
		hDll = LoadLibraryA(path.c_str());
		using FunctionPtr = IBattleshipGameAlgo* (*) ();
		if (hDll)
		{
			// GetAlgorithm function
			auto GetAlgorithm = reinterpret_cast<FunctionPtr>(GetProcAddress(hDll, "GetAlgorithm"));
			instance = GetAlgorithm();
		}
		else {
			throw exception("failed to load library");
		}
	}
	catch (exception e) {
		throw e;
	}
	
	return instance;
}

bool BattleManager::validateFilesExistanceAndBoardValidate(const std::string& dirPath) {
	vector<string> suffixes = { "sboard", "dll" }; // file suffixes to validate
	vector<string> errors = { "Missing board file (*.sboard) looking in path: ", "Missing an algorithm (dll) file looking in path: " };
	vector<string> dllFiels;
	bool isBoardFound = false;
	bool validBoard = false;
	filePaths = vector<string>(3, "");
	bool isFileNotFound = false;
	string searchIn;
	
	//check if dirPath provided
	if (dirPath.empty()) {
		searchIn = ".";
	}
	else {
		searchIn = dirPath;
	}
	
	//if dirPath provided check if dir exists
	if (searchIn != "." && !Utility::dirExists(searchIn)) {
		cout << "Wrong path : " << searchIn << endl;
		return false;
	}
	
	//get file names in dir path
	vector<string> fileNames;
	Utility::getFileNamesFromDir(fileNames, searchIn);

	for (unsigned int i = 0; i < fileNames.size(); i++) {
		if (Utility::has_suffix(fileNames[i], suffixes[BOARD_PATH])) {
			if (!isBoardFound) {
				filePaths[BOARD_PATH] = searchIn + '\\' + fileNames[i];
				isBoardFound = true;
			}
		}
		if (Utility::has_suffix(fileNames[i], suffixes[1])) {
			dllFiels.push_back(fileNames[i]);
		}
	}

	if(!isBoardFound)
	{
		cout << errors[BOARD_PATH] << searchIn << endl;
		isFileNotFound = true;
	}
	else
	{
		loadBoard(filePaths[BOARD_PATH]); //load and 
		validBoard = validateBoard(); //validate the board
	}

	if(dllFiels.size() <2 ){
		cout << errors[DLL_A_PATH] << searchIn << endl;
		isFileNotFound = true;
	}
	else
	{
		sort(dllFiels.begin(), dllFiels.end());
		filePaths[DLL_A_PATH] = searchIn + '\\' + dllFiels[0];
		filePaths[DLL_B_PATH] = searchIn + '\\' + dllFiels[1];
	}

	if (isFileNotFound || !validBoard)return false; // file not found
	
	return true;
	
}



bool BattleManager::runBattle(const string & dirPath)
{
	int currentTurn = 0;// A turn when 0 , B turn when 1;
	if(!validateFilesExistanceAndBoardValidate(dirPath))return false; //validate all input files existanc and board validate
	// set player boards
	//create tmp char** from board to pass to function
	
	try {
		
		playerA = loadFromDLL(filePaths[DLL_A_PATH]);
	
	}
	catch (exception e) {
		cout << "Cannot load dll: " << filePaths[DLL_A_PATH] << endl;
		return false;
	}

	char** boardAchar = new char*[this->boardSize];
	char** boardBchar = new char*[this->boardSize];
	buildUserBoards(boardAchar, boardBchar);

	playerA->setBoard(0, const_cast<const char**>(boardAchar), static_cast<int> (this->boardSize), static_cast<int> (this->boardSize)); // should only contain each players board but since it is almost empty imple doesn't matter
	//free the tmp board, no need to free the char* generated by c_str(), as it points too the string which will manage it's own lifetime
	deleteBoard(boardAchar);
	if (!playerA->init(dirPath))
	{
		cout << "Algorithm initialization failed for dll: " << filePaths[DLL_A_PATH] << endl;
		deleteBoard(boardBchar);
		return false;
	}

	try {
		
		playerB = loadFromDLL(filePaths[DLL_B_PATH]);

	}
	catch (exception e) {
		cout << "Cannot load dll: " << filePaths[DLL_B_PATH] << endl;
		deleteBoard(boardBchar);
		return false;
	}
	playerB->setBoard(1, const_cast<const char**>(boardBchar), static_cast<int> (this->boardSize), static_cast<int>(this->boardSize));
	deleteBoard(boardBchar);

	if(!playerB->init(dirPath))
	{
		cout << "Algorithm initialization failed for dll: " << filePaths[DLL_B_PATH] << endl;
		return false;
	}

	if (!quiet)cp.print_borad();//print board if not quiet
																		 
	//init player's status
	bool playerAFin = false; bool playerBFin = false;
	int playerAScore = 0; int playerBScore = 0;

	while (true) {
		if (playerAFin && playerBFin) {
			Utility::printFinishMsg(playerAScore, playerBScore, -1);
			return true;
		}
		pair<int, int> currAttack = (currentTurn == A_TURN) ? playerA->attack() : playerB->attack();
		if (currAttack == pair<int, int>(-1, -1)) {
			//mark player finished , switch turns and continue
			(currentTurn == A_TURN) ? playerAFin = true : playerBFin = true;
			currentTurn = (currentTurn + 1) % 2; 
			continue;
		}
		Position posToAttack = Position(currAttack.first - 1, currAttack.second - 1);
		auto result = (currentTurn == A_TURN) ? fleetB.executeAttack(posToAttack) : fleetA.executeAttack(posToAttack);
		auto selfResult = (currentTurn == A_TURN) ? fleetA.executeAttack(posToAttack) : fleetB.executeAttack(posToAttack);
	
		AttackResult unifiedRes = AttackResult::Miss;
		bool shouldSwitchTurn = false;
		switch (result.first) {
			case AttackResult::Miss ://switch turns 
				shouldSwitchTurn = true;
				break;
			case AttackResult::Hit : 
				unifiedRes = AttackResult::Hit;
				break;
			case AttackResult::Sink ://update score
				unifiedRes = AttackResult::Sink;
				(currentTurn == A_TURN) ? playerAScore += result.second->getScore() : playerBScore += result.second->getScore();
				break;
		}
		//if I Missed opponent might have hit myself
		if (result.first == AttackResult::Miss) {
			switch (selfResult.first) {
				case AttackResult::Miss:
					unifiedRes = AttackResult::Miss;
					break;
				case AttackResult::Hit:
					unifiedRes = AttackResult::Hit;
					break;
				case AttackResult::Sink://update score
					unifiedRes = AttackResult::Sink;
					(currentTurn == A_TURN) ? playerBScore += selfResult.second->getScore() : playerAScore += selfResult.second->getScore();
					break;
			}
		}
		playerA->notifyOnAttackResult(currentTurn, currAttack.first, currAttack.second, unifiedRes); //notify A
		playerB->notifyOnAttackResult(currentTurn, currAttack.first, currAttack.second, unifiedRes); //notify B
		if (!quiet)cp.print_attack(posToAttack, currentTurn, unifiedRes);//print attack to console if not quiet
		//check game status and report accordingly
		if (!fleetA.isNotLose()) { // a lost meaning b won
			Utility::printFinishMsg(playerAScore, playerBScore, B_TURN);
			return true;
		}
		if(!fleetB.isNotLose()) { // B lost meaning A won
			Utility::printFinishMsg(playerAScore, playerBScore, A_TURN);
			return true;
		}
		if (shouldSwitchTurn) {
			currentTurn = (currentTurn + 1) % 2;
		}
		continue;
	}
	return true;

}


void BattleManager::deleteBoard(char** boardToDelete) const
{
	for (int i = 0; i < this->boardSize; i++) {
		delete[] boardToDelete[i];
	}
	delete[] boardToDelete;
}




	
